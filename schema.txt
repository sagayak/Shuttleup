
-- ==========================================================
-- SHUTTLEUP DATABASE SCHEMA (IDEMPOTENT)
-- ==========================================================

-- Enable extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- 1. PROFILES TABLE
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID REFERENCES auth.users ON DELETE CASCADE PRIMARY KEY,
    user_numeric_id SERIAL UNIQUE,
    username TEXT UNIQUE NOT NULL,
    full_name TEXT NOT NULL,
    email TEXT UNIQUE NOT NULL,
    role TEXT DEFAULT 'player' CHECK (role IN ('superadmin', 'admin', 'player', 'scorer')),
    credits INTEGER DEFAULT 0 CHECK (credits >= 0),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 2. TOURNAMENTS TABLE
CREATE TABLE IF NOT EXISTS public.tournaments (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    tournament_numeric_id SERIAL UNIQUE,
    name TEXT NOT NULL,
    organizer_id UUID REFERENCES public.profiles(id) NOT NULL,
    start_date TIMESTAMPTZ NOT NULL,
    end_date TIMESTAMPTZ NOT NULL,
    location TEXT,
    lat_lng JSONB,
    format TEXT DEFAULT 'knockout' CHECK (format IN ('league', 'knockout')),
    privacy TEXT DEFAULT 'public' CHECK (privacy IN ('public', 'protected')),
    player_limit INTEGER,
    team_limit INTEGER,
    scorer_pin TEXT,
    is_locked BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 3. TEAMS TABLE
CREATE TABLE IF NOT EXISTS public.teams (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    tournament_id UUID REFERENCES public.tournaments(id) ON DELETE CASCADE NOT NULL,
    name TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 4. TEAM MEMBERS TABLE
CREATE TABLE IF NOT EXISTS public.team_members (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    team_id UUID REFERENCES public.teams(id) ON DELETE CASCADE NOT NULL,
    profile_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(team_id, profile_id)
);

-- 5. MATCHES TABLE
CREATE TABLE IF NOT EXISTS public.matches (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    tournament_id UUID REFERENCES public.tournaments(id) ON DELETE CASCADE NOT NULL,
    match_order INTEGER NOT NULL,
    team_a_id UUID REFERENCES public.teams(id),
    team_b_id UUID REFERENCES public.teams(id),
    umpire_name TEXT,
    scheduled_time TIMESTAMPTZ,
    status TEXT DEFAULT 'scheduled' CHECK (status IN ('scheduled', 'live', 'completed', 'cancelled')),
    score_a INTEGER DEFAULT 0,
    score_b INTEGER DEFAULT 0,
    sets_won_a INTEGER DEFAULT 0,
    sets_won_b INTEGER DEFAULT 0,
    winner_team_id UUID REFERENCES public.teams(id),
    max_points INTEGER DEFAULT 21,
    current_set INTEGER DEFAULT 1,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 6. CREDIT TRANSACTIONS
CREATE TABLE IF NOT EXISTS public.credit_transactions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    profile_id UUID REFERENCES public.profiles(id) NOT NULL,
    amount INTEGER NOT NULL,
    type TEXT CHECK (type IN ('purchase', 'deduction', 'refund', 'admin_override')),
    description TEXT,
    razorpay_payment_id TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Reset Sequences
ALTER SEQUENCE IF EXISTS tournaments_tournament_numeric_id_seq RESTART WITH 1000;
ALTER SEQUENCE IF EXISTS profiles_user_numeric_id_seq RESTART WITH 5000;

-- 7. RLS POLICIES
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Public profiles are viewable by everyone" ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone" ON public.profiles FOR SELECT USING (true);
DROP POLICY IF EXISTS "Users can update own profile" ON public.profiles;
CREATE POLICY "Users can update own profile" ON public.profiles FOR UPDATE USING (auth.uid() = id);

ALTER TABLE public.tournaments ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Tournaments are viewable by everyone" ON public.tournaments;
CREATE POLICY "Tournaments are viewable by everyone" ON public.tournaments FOR SELECT USING (true);
DROP POLICY IF EXISTS "Organizers can insert tournaments" ON public.tournaments;
CREATE POLICY "Organizers can insert tournaments" ON public.tournaments FOR INSERT WITH CHECK (auth.uid() = organizer_id);
DROP POLICY IF EXISTS "Organizers can update own tournaments" ON public.tournaments;
CREATE POLICY "Organizers can update own tournaments" ON public.tournaments FOR UPDATE USING (auth.uid() = organizer_id OR EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND role = 'superadmin'));

-- 8. TRIGGER FOR PROFILES
CREATE OR REPLACE FUNCTION public.handle_new_user() 
RETURNS TRIGGER 
LANGUAGE plpgsql 
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  INSERT INTO public.profiles (id, full_name, username, email, role, credits)
  VALUES (
    new.id, 
    COALESCE(new.raw_user_meta_data->>'full_name', 'Player'), 
    COALESCE(new.raw_user_meta_data->>'username', 'user_' || substr(new.id::text, 1, 8)),
    new.email,
    'player',
    0
  ) ON CONFLICT (id) DO UPDATE SET
    full_name = EXCLUDED.full_name,
    username = EXCLUDED.username,
    email = EXCLUDED.email;
  RETURN new;
END;
$$;

DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- 9. RPC FUNCTIONS (WITH EXPLICIT GRANTS)
CREATE OR REPLACE FUNCTION public.deduct_credits_for_tournament(user_uuid UUID, cost INTEGER)
RETURNS BOOLEAN AS $$
DECLARE
    current_credits INTEGER;
BEGIN
    SELECT credits INTO current_credits FROM public.profiles WHERE id = user_uuid FOR UPDATE;
    IF current_credits IS NULL THEN RAISE EXCEPTION 'Profile not found'; END IF;
    IF current_credits < cost THEN RAISE EXCEPTION 'Insufficient credits'; END IF;
    
    UPDATE public.profiles SET credits = credits - cost WHERE id = user_uuid;
    INSERT INTO public.credit_transactions (profile_id, amount, type, description)
    VALUES (user_uuid, -cost, 'deduction', 'Tournament hosting fee');
    RETURN TRUE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.add_credits_after_payment(user_uuid UUID, topup_amount INTEGER, payment_id TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    -- Ensure profile exists
    IF NOT EXISTS (SELECT 1 FROM public.profiles WHERE id = user_uuid) THEN
        RAISE EXCEPTION 'Profile record not found for user %. Please refresh and sync profile.', user_uuid;
    END IF;

    UPDATE public.profiles SET credits = credits + topup_amount WHERE id = user_uuid;
    INSERT INTO public.credit_transactions (profile_id, amount, type, description, razorpay_payment_id)
    VALUES (user_uuid, topup_amount, 'purchase', 'Credit Top-up', payment_id);
    RETURN TRUE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- IMPORTANT: Grant execute permissions to public/authenticated users
GRANT EXECUTE ON FUNCTION public.deduct_credits_for_tournament(UUID, INTEGER) TO authenticated;
GRANT EXECUTE ON FUNCTION public.deduct_credits_for_tournament(UUID, INTEGER) TO service_role;
GRANT EXECUTE ON FUNCTION public.add_credits_after_payment(UUID, INTEGER, TEXT) TO authenticated;
GRANT EXECUTE ON FUNCTION public.add_credits_after_payment(UUID, INTEGER, TEXT) TO service_role;
